"""
Module containing functions to generate prioritized permutations.
"""

from collections import Counter
from collections.abc import Generator
from itertools import combinations_with_replacement, combinations
from math import floor
from sympy.utilities.iterables import multiset_permutations


def get_products(priorities:list,
                 min_length:int = 4,
                 max_length:int = 7) -> Generator[str, None, None]:
    """Generates strings for each multiset permutation for each possible
    combination (with replacement, that would result in a string of length
    within the min and max length specified) of a given set of priorities,
    in order of their priority. Order of priority is determined by the order
    of the priorities provided. This order is similar to, but not the same
    as lexigraphical order. It is optimized such that any version of a
    string containing a given set of priorities will be yielded before a
    string containing lower priorities. Permutations for a given
    combination are returned with the highest priorities occuring in the
    string first. Combinations with replacement of equal sets of priorities
    are returned shortest to longest (for the final resulting string length).

    Duplicate values may be generated but will not be returned.
    Duplicates are only generated when a priority can be formed from a
    combination of one or more lower priorities.

    #TODO: Make the algorithm check if duplicates are possible before checking for them

    Duplicates are prevented from being returned by determining what the
    highest priorities are the current string could be made from and
    checking if the priorities used to generate the current string match.
    This has the benefit of not requiring a recording of which strings have
    already been generated.

    #TODO: Need to find out what that kind of ordering is called...

    The originally intended application was generating strings for password
    crackers, such that a complete word list did not need to be generated,
    stored, and sorted in order to optimize it.


    Parameters
    ----------
    priorities : list
        A list of sub strings to generate the final strings from.
        Order from highest priority to lowest priority is left to right.
    min_length : int
        Sets the minimum length of genereated strings. Default is 4.
    max_length : int
        Sets the minimum length of genereated strings. Default is 7.

    Returns
    -------
    Generator[str, None, None]
        Returns a generator of strings.
    """

    # Cleaning Input
    priorities = clean_input(priorities, max_length)

    # Finding Possible Combinations with given elements length
    tracker = [[count, len(item)] for count, item in enumerate(priorities)]
    shortest_priority_length = min([item[1] for item in tracker])

    max_replacements = floor(max_length/shortest_priority_length)

    unique_combos = []
    for replacements in range(max_replacements+1):
        for combo in combinations_with_replacement(tracker, replacements):
            combo_length = sum([item[1] for item in combo])
            if min_length <= combo_length <= max_length:
                unique_combos += [combo]

    # Sorting Priorities
    piority_combos = sort_priorities(priorities, unique_combos)

    # Generating Output
    for combo in piority_combos:
        for permutation in multiset_permutations(combo):
            final_str = ""
            for inner_index in permutation:
                final_str += str(priorities[inner_index])

            if is_first_occurance(final_str, priorities, permutation):
                yield final_str


def clean_input(orig_priorities:list, max_length:int) -> list:
    cleaned_priorities = []

    # If the list has more than one copy of the same element,
    # we don't know which is valid (higher or lower priority)
    dupes = [item for item, count in Counter(orig_priorities).items() if count > 1]
    if len(dupes) > 0:
        print("Warning - List of priorties contains duplicates.")
        print(dupes)
        print("Duplicates must be removed before proceeding.")
        return cleaned_priorities

    cleaned_priorities = [str(priority) for priority in orig_priorities]
    cleaned_priorities = [priority for priority in cleaned_priorities \
                          if len(priority) <= max_length]
    cleaned_priorities = remove_redundant_priorities(cleaned_priorities)
    return cleaned_priorities


def remove_redundant_priorities(orig_priorities:list) -> list:
    """If a priority can be formed from one or more higher priorities
    then its equivalent strings will be generated by those priorities
    before it is used.  Because of this, it is redundant and we can remove it.

    Parameters
    ----------
    orig_priorities : list
        A list of strings containing the priorities to check.

    Returns
    -------
    list
        The original priority list with redundant priorities removed.

    """

    new_priorities = []
    for priority in orig_priorities:
        if not is_made_of_substrings(priority, new_priorities):
            new_priorities.append(priority)
    return new_priorities


def is_made_of_substrings(main_string:str, sub_strings:list) -> bool:
    """Check if a string can be formed from a list of substrings.

    Parameters
    ----------
    main_string : str
        Main string to check.
    sub_strings : list
        Substrings to form main_string with.

    Returns
    -------
    bool
        Returns True if the main_string can be generated from one or
        more of the sub_strings (with or without repetition), and returns
        False otherwise.

    """

    if main_string in sub_strings:
        return True

    for split_point in range(len(main_string)-1):
        left_string, right_string = main_string[:split_point+1], \
                                    main_string[split_point+1:]
        if is_made_of_substrings(left_string, sub_strings) and \
           is_made_of_substrings(right_string, sub_strings):
            return True

    return False


def sort_priorities(priorities:list, unique_combos:list) -> list:
    #TODO: This functions is tooo loong, break it up...

    new_list = []
    all_indexes = list(range(len(priorities)))

    # This section creates a list of the order in which we want to test
    # combinations of the priorities (referencing them by index)

    k_list = []
    indexes = list(range(len(priorities)))
    for i in range(len(priorities)):
        temp_list = []
        for combination in combinations(indexes,i+1):
            temp_list.append(list(combination))
        k_list.append(temp_list)

    included_indexes = []

    top_items = [item[0] for item in k_list]
    while k_list:
        top_items_values = []
        for item in top_items:
            temp_val = 0
            str_val = "0." + ''.join([str(elem) for elem in item])
            temp_val = float(str_val)
            top_items_values.append(temp_val)

        min_index = top_items_values.index(min(top_items_values))
        if isinstance(k_list[min_index][0],list):
            included_indexes.append(k_list[min_index][0].copy())
        else:
            included_indexes.append(k_list[min_index][0])

        k_list[min_index].pop(0)
        k_list = list(filter(None, k_list))
        top_items = [item[0] for item in k_list]

    # This next section adds the combinations (which were possible with the length contstrains)
    # to a list the in order of the priorities we set above
    for thing in included_indexes:
        temp_indexes = set(thing)
        excluded_indexes = set(all_indexes)-temp_indexes

        for item in unique_combos:
            combo_indexes = [val[0] for val in item]
            if all(x in combo_indexes for x in temp_indexes) and \
               not any(y in combo_indexes for y in excluded_indexes):
                new_list += [combo_indexes]

    return new_list


def is_first_occurance(main_string:str, sub_strings:list, \
                       current_permutation:list) -> bool:
    # another method to check for first occurances
    # faster, but misses some occurances
    # for i in range(min(current_permutation)):
    #     if main_string.find(sub_strings[i]) != -1:
    #         return False

    first_permutation = get_first_permutation(main_string, sub_strings)
    return first_permutation == current_permutation


def get_first_permutation(main_string:str, sub_strings:list) -> list:
    first_combo = []
    remaining_string = main_string

    for sub_str_idx, sub_str in enumerate(sub_strings):
        good_sub_string = False
        if len(sub_str) > len(main_string):
            continue

        for char_idx, char in enumerate(sub_str):
            if char == main_string[char_idx]:
                good_sub_string = True
            else:
                good_sub_string = False
                break

        if good_sub_string:
            first_combo.append(sub_str_idx)
            remaining_string = main_string[len(sub_str):]
            if remaining_string != "":
                remaining_list = get_first_permutation(remaining_string, sub_strings)
                if remaining_list:
                    first_combo.extend(remaining_list)
                    break
            else:
                break

    return first_combo
